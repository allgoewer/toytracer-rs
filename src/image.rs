use crate::vec3::Color;
use std::io;
use std::ops;

pub struct Image {
    dim: (usize, usize),
    buf: Vec<Color>,
}

impl Image {
    pub fn new(width: usize, height: usize) -> Self {
        let mut buf = Vec::with_capacity(width * height);
        buf.resize(buf.capacity(), Color::new(0.0, 0.0, 0.0));

        Self {
            dim: (width, height),
            buf,
        }
    }

    pub fn dim(&self) -> (usize, usize) {
        self.dim
    }

    pub fn to_ppm<W: io::Write>(&self, w: &mut W) -> io::Result<()> {
        let (width, height) = self.dim;
        writeln!(w, "P3")?;
        writeln!(w, "# Raytraced image generated by Maiks raytracer")?;
        writeln!(w, "{} {}\n255\n", width, height)?;

        for j in (0..height).rev() {
            for i in 0..width {
                let (r, g, b) = self[(i, j)].xyz();

                let r = (r * 255.999) as u8;
                let g = (g * 255.999) as u8;
                let b = (b * 255.999) as u8;

                writeln!(w, "{} {} {}", r, g, b)?;
            }
        }

        Ok(())
    }
}

impl ops::Index<(usize, usize)> for Image {
    type Output = Color;
    fn index(&self, index: (usize, usize)) -> &Self::Output {
        let w = self.dim.0;
        &self.buf[index.0 + index.1 * w]
    }
}

impl ops::IndexMut<(usize, usize)> for Image {
    fn index_mut(&mut self, index: (usize, usize)) -> &mut Self::Output {
        let w = self.dim.0;
        &mut self.buf[index.0 + index.1 * w]
    }
}
